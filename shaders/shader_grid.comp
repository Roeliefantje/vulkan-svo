#version 450

struct Particle {
    vec2 position;
    vec2 velocity;
    vec4 color;
};

layout (binding = 0) uniform ParameterUBO {
    int width;
    int height;
    int depth;
} ubo;

layout (binding = 3) uniform CameraUBO {
    vec3 position;
    vec3 direction;
    vec3 up;
    vec2 resolution;
    float fov;
} camera;

//Std430 = tightly packed, std140 is not, no clue how exactly it works...
layout(std430, binding = 1) buffer ParticleSSBOIn {
    int gridValues[ ];
};

layout(binding = 2, rgba8) uniform writeonly image2D outputImage;



int MAX_RAY_STEPS = 5000;



int getIndex(ivec3 mapPos) {
//    return int(dot(mapPos, ivec3(1, ubo.width, ubo.width * ubo.height)));
    return mapPos.x + mapPos.y * ubo.width + mapPos.z * ubo.width * ubo.height;
}

int getValue(ivec3 mapPos) {
    if (any(greaterThanEqual(mapPos, ivec3(ubo.width, ubo.depth, ubo.height))) || any(greaterThan(ivec3(0), mapPos))) {
        return 0;
    }
    int index = getIndex(mapPos);
    if (index >= ubo.width * ubo.height * ubo.depth || index < 0) {
        return 0;
    }

    return gridValues[index];
}

bool intersectGrid(vec3 rayDir, vec3 rayPos) {
    vec3 invDir = 1.0 / rayDir;

    vec3 t1 = (vec3(0) - rayPos) * invDir;
    vec3 t2 = (vec3(ubo.width, ubo.depth, ubo.height) - rayPos) * invDir;

    vec3 tmin = min(t1, t2);
    vec3 tmax = max(t1, t2);

    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit  = min(min(tmax.x, tmax.y), tmax.z);

    return tExit >= max(tEnter, 0.0);
}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    uvec2 pixelCoord = gl_GlobalInvocationID.xy;
    vec2 normalized_coord = (vec2(pixelCoord) + 0.5) / camera.resolution * 2.0 - 1.0;

    vec3 forward = camera.direction;
    vec3 right = normalize(cross(forward, camera.up));
    vec3 up = normalize(cross(right, forward));

    // Perspective correction using vertical FOV
    float aspect = camera.resolution.x / camera.resolution.y;
    float fovScale = tan(camera.fov * 0.5);

    vec3 rayDir = normalize(
        forward +
        normalized_coord.x * aspect * fovScale * right +
        normalized_coord.y * fovScale * up
    );

    vec3 rayPos = camera.position;

    ivec3 mapPos = ivec3(floor(rayPos));

    //  Distance per axis to travel to the next floor
    vec3 deltaDist = abs(1.0 / rayDir);

    ivec3 rayStep = ivec3(sign(rayDir));
    vec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
    bvec3 mask = bvec3(false, false, true);

    if (!intersectGrid(rayDir, rayPos)) {
        imageStore(outputImage, ivec2(pixelCoord), vec4(0.1, 0.1, 0.1, 1.0));
        return;
    }

    for (int i = 0; i < MAX_RAY_STEPS; i++) {

        if (getValue(mapPos) >= 1) break;
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

        sideDist -= dot(vec3(mask), sideDist) * deltaDist;
        sideDist += vec3(mask) * deltaDist;
        mapPos += ivec3(vec3(mask)) * rayStep;

    }

    vec3 color = vec3(dot(vec3(mask), vec3(0.5, 1.0, 0.75)));
    if (getValue(mapPos) == 0) {
        color = vec3(0.1, 0.1, 0.1);
    }

    imageStore(outputImage, ivec2(pixelCoord), vec4(color, 1.0));
}