#version 450

struct Particle {
    vec2 position;
    vec2 velocity;
    vec4 color;
};

layout (binding = 0) uniform ParameterUBO {
    int width;
    int height;
    int depth;
} ubo;

layout (binding = 3) uniform CameraUBO {
    vec3 position;
    vec3 direction;
    vec3 up;
    vec2 resolution;
    float fov;
} camera;

//Std430 = tightly packed, std140 is not, no clue how exactly it works...
layout(std430, binding = 1) buffer ParticleSSBOIn {
    int svo[ ];
};

layout(binding = 2, rgba8) uniform writeonly image2D outputImage;



int MAX_RAY_STEPS = 5000;
int MAX_DEPTH = 10;


struct Node {
    uint childMask;
    uint index;
};


Node convertNode(uint value){
    Node node;
    node.childMask = value >> 24;
    node.index = value & 0xFFFFFFu;

    return node;
}

bool intersectGrid(vec3 rayDir, vec3 rayPos) {
    vec3 invDir = 1.0 / rayDir;

    vec3 t1 = (vec3(0) - rayPos) * invDir;
    vec3 t2 = (vec3(ubo.width, ubo.depth, ubo.height) - rayPos) * invDir;

    vec3 tmin = min(t1, t2);
    vec3 tmax = max(t1, t2);

    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit  = min(min(tmax.x, tmax.y), tmax.z);

    return tExit >= max(tEnter, 0.0);
}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    uvec2 pixelCoord = gl_GlobalInvocationID.xy;
    vec2 normalized_coord = (vec2(pixelCoord) + 0.5) / camera.resolution * 2.0 - 1.0;

    vec3 forward = camera.direction;
    vec3 right = normalize(cross(forward, camera.up));
    vec3 up = normalize(cross(right, forward));

    // Perspective correction using vertical FOV
    float aspect = camera.resolution.x / camera.resolution.y;
    float fovScale = tan(camera.fov * 0.5);

    vec3 rayDir = normalize(
        forward +
        normalized_coord.x * aspect * fovScale * right +
        normalized_coord.y * fovScale * up
    );

    vec3 rayPos = camera.position;
    //  Distance per axis to travel to the next tile,
    vec3 deltaDist = abs(1.0 / rayDir);
    ivec3 rayStep = ivec3(sign(rayDir));
    ivec3 mapPos = ivec3(floor(rayPos));

    uint level = 0;
    Node[] stack = Node[MAX_DEPTH];
    Node currentNode = convertNode(svo[0]);

    for (int i = 0; i < MAX_RAY_STEPS; i++) {
        if (currentNode.childMask == 0u) {
            //Ray starts inside of a voxel
            imageStore(outputImage, ivec2(pixelCoord), vec4(1.0));
            return;
        }

        //Get the currentNodes Size
        int nodeSize = max(1, ubo.width >> level);
        vec3 localPos = fract(rayPos / float(nodeSize));
        //Check if ray is outside of SVO
        if (level == 0 && (any(greaterThan(localPos, vec3(1.0))) || any(greaterThan(vec3(0.0), localPos)))) {
            //TODO: Check bounding box and then move the ray to the start
            break;
        }
        //Get the childCoord by getting the 0.6 * 2, 1.2 = 1, etc...
        ivec3 childCoords = ivec3(localPos * 2.0);

        //Convert to the flattened values
        int childIndex = childCoords.z * 4 + childCoords.y * 2 + childCoords.x;

        if (((currentNode.childMask >> childIndex) & 1u) == 0u) {
            break;
        }

        //Shift off everything past the child and the child so we know how many children came before
        int childOffset = bitCount(currentNode.childMask >> (childIndex + 1));
        stack[level] = currentNode;
        currentNode = convertNode(svo[currentNode.index + childOffset]);
        level += 1;
    }


    bvec3 mask = bvec3(false, false, true);
    //at level 0, this will be 512, etc.
    int childNodeSize = max(1, ubo.width >> level + 1);
    vec3 localPos = fract(rayPos / float(childNodeSize));
    ivec3 childCoords = ivec3(localPos);
    vec3 sideDist = (sign(rayDir) * (vec3(childCoords) - localPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
    for (int i = 0; i < MAX_RAY_STEPS; i++){
        if (currentNode.childMask == 0u || level == MAX_DEPTH) {
            //Ray collided with voxel
            break;
        }

        int childIndex = childCoords.z * 4 + childCoords.y * 2 + childCoords.x;
        if (((currentNode.childMask >> childIndex) & 1u) == 1u) {
            //Descend
            stack[level] = currentNode;
            level += 1;
            int childOffset = bitCount(currentNode.childMask >> (childIndex + 1));
            currentNode = convertNode(svo[currentNode.index + childOffset]);


            childNodeSize = max(1, ubo.width >> (level + 1));
            localPos = fract(rayPos / float(childNodeSize));
            childCoords = ivec3(localPos);
            sideDist = (sign(rayDir) * (vec3(childCoords) - localPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
        } else {
            //DDA to next child
            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
            sideDist += vec3(mask) * deltaDist;
            childCoords += ivec3(vec3(mask)) * rayStep;

            if (any(greaterThan(childCoords, vec3(1.0))) || any(greaterThan(vec3(0.0), childCoords))) {
                //Ascend
                rayPos += dot(vec3(mask), sideDist) * rayDir * childNodeSize;
                level -= 1;
                //TODO: this will break if level is outside :), should add if statement or break here or whatever.
                currentNode = stack[level];

                childNodeSize = max(1, ubo.width >> (level + 1));
                localPos = fract(rayPos / float(childNodeSize));
                childCoords = ivec3(localPos);
                sideDist = (sign(rayDir) * (vec3(childCoords) - localPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;

            }

        }


    }


    vec3 color = vec3(dot(vec3(mask), vec3(0.5, 1.0, 0.75)));
    //TODO: Change this to something else
    if (getValue(mapPos) == 0) {
        color = vec3(0.1, 0.1, 0.1);
    }

    imageStore(outputImage, ivec2(pixelCoord), vec4(color, 1.0));
}