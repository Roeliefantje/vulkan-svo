#version 450
#extension GL_EXT_nonuniform_qualifier : require
//Look at: https://www.shadertoy.com/view/4sVfWw

struct Particle {
    vec2 position;
    vec2 velocity;
    vec4 color;
};

struct Chunk {
    uint resolution;
    uint rootNodeIndex;
};

layout (binding = 0) uniform ParameterUBO {
    vec3 lightPosition;
    uint width;
    uint bufferSize;
    uint gridSize;
} ubo;

layout (binding = 3) uniform CameraUBO {
    vec3 position;
    vec3 direction;
    vec3 up;
    vec2 resolution;
    float fov;
} camera;

//Std430 = tightly packed, std140 is not, no clue how exactly it works...
layout(std430, binding = 5) buffer VoxelSSBO{
    uint svo[ ];
} voxelSSBOs[];

layout(std430, binding = 4) buffer gridSSBO {
    Chunk grid[ ];
};

layout(std430, binding = 1) buffer FarValuesSSBO {
    uint farValues[ ];
};

layout(binding = 2, rgba8) uniform writeonly image2D outputImage;




int MAX_RAY_STEPS = 5000;
#define MAX_DEPTH 16
#define MAX_DISTANCE 300000.0


struct Node {
    uint childMask;
    uint index;
    uint color;
};

struct StackInfo {
    Node node;
    vec3 sideDist;
    ivec3 childCoord;
};


Node convertNode(uint value, uint parentIndex){
    Node node;
    node.childMask = (value >> 24) & 0xFFu;
    bool isFar = (value & (1u << 23)) != 0u;
    uint childIndex = value & 0x007FFFFFu;
    node.index = (isFar ? farValues[childIndex] : childIndex) + parentIndex;
    node.color = value & 0x00FFFFFFu;; //Todo! also use the far bit so red can have 16 values as well.

    return node;
}

Node getNode(uint index) {
    uint chunkIndex = index / ubo.bufferSize;
    uint svoIndex = index % ubo.bufferSize;
    uint value = voxelSSBOs[chunkIndex].svo[svoIndex];

    return convertNode(value, index);
}

vec3 voxel(vec3 ro, vec3 rd, vec3 ird, float size)
{
    size *= 0.5;

    vec3 hit = -(sign(rd)*(ro-size)-size)*ird;

    return hit;
}


layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    uvec2 pixelCoord = gl_GlobalInvocationID.xy;
    vec2 normalized_coord = (vec2(pixelCoord) + 0.5) / camera.resolution * 2.0 - 1.0;

    vec3 forward = camera.direction;
    vec3 right = normalize(cross(forward, camera.up));
    vec3 up = normalize(cross(right, forward));

    // Perspective correction using vertical FOV
    float aspect = camera.resolution.x / camera.resolution.y;
    float fovScale = tan(camera.fov * 0.5);

    vec3 rayDir = normalize(
        forward +
        normalized_coord.x * aspect * fovScale * right +
        normalized_coord.y * fovScale * up
    );

    vec3 rayPos = camera.position;
    ivec3 rayStep = ivec3(sign(rayDir)); //The direction of the ray

    //Initialize stuffs

    float size = ubo.width;
    ivec3 gridCoord = ivec3(rayPos / size);
//    if (any(greaterThanEqual(gridCoord, ivec3(ubo.gridSize, ubo.gridSize, 1))) || any(lessThan(gridCoord, ivec3(0)))) {
//        return;
//    }

    int level = 0;
    Chunk currentChunk = grid[gridCoord.y * ubo.gridSize + gridCoord.x];
    Node stack[MAX_DEPTH];
    Node currentNode = getNode(currentChunk.rootNodeIndex);
    Node empty;
    empty.index = 0;

    if (any(greaterThanEqual(gridCoord, ivec3(ubo.gridSize, ubo.gridSize, 1))) || any(lessThan(gridCoord, ivec3(0)))) {
        currentNode = empty;
    }

    vec3 color = vec3(0.1);
    bvec3 mask = bvec3(false, false, false);


    vec3 lro = rayPos - vec3(gridCoord) * size;
//    vec3 lro = mod(rayPos, size); // Local ray origin (Should always already be inside 1.0, but for sanity)
    ivec3 fro = ivec3(0); //The global voxel position we are currently in (should always start as 0,0,0)
    vec3 rdsign = sign(rayDir);
    ivec3 irdsign = ivec3(rdsign);
    vec3 ird = 1.0/max(abs(rayDir), 0.001); //inv ray dir to calculate the distance to voxel boundaries and stuff
    bool exitoct = false;
    bool movegrid = false;
    float dist = 0.0; //Total distance the ray traversed
    float fdist = 0.0;
    int collisions = 0;

    for(int i = 0; i < MAX_RAY_STEPS; i++) {
        if(dist > MAX_DISTANCE) break;

        if (movegrid) {
            //Outside of current Octree, move grid coords and go from there
            size = ubo.width;
            level = 0;
            rayPos = lro + vec3(fro) + vec3(gridCoord * ubo.width);
            gridCoord += ivec3(mask) * irdsign;
            lro = rayPos - vec3(gridCoord) * ubo.width;
            fro = ivec3(0);

            currentChunk = grid[gridCoord.y * ubo.gridSize + gridCoord.x];
            currentNode = getNode(currentChunk.rootNodeIndex);

            if (any(greaterThanEqual(gridCoord, ivec3(ubo.gridSize, ubo.gridSize, 1))) || any(lessThan(gridCoord, ivec3(0)))) {
//                gridCoord = ivec3(gridCoord.x % ubo.gridSize, gridCoord.y % ubo.gridSize, gridCoord.z);
//                if (gridCoord.z >= 1){
//                    currentNode = empty;
//                }
                break;
            }

            movegrid = false;
            exitoct = false;
        }

        if (exitoct) {
            //Todo!: Improve this to do it in one go
            //Snap newfro to multiple of new size to get the global voxel position again
            ivec3 newfro = ivec3(floor( vec3(fro) / (size * 2.0))) * (int(size) * 2);


            lro += fro - newfro;
            fro = newfro;
            size *= 2.0;

            level--;
            if (level <= 0) {
                movegrid = true;
                continue;
            }

            ivec3 childCoord = (newfro / int(size)) % 2;
            int childIndex = childCoord.z * 4 + childCoord.y * 2 + childCoord.x;
            int childOffset = bitCount(stack[level - 1].childMask >> (8 - childIndex));
            uint parentIndex = stack[level - 1].index + childOffset;
            currentNode = (stack[level - 1].childMask >> (7 - childIndex) & 1u) == 1u ? getNode(parentIndex) : empty;

            //Fetch the new voxCoord and see if it is still on a border
            // +0.5 centers the voxel range so borders lie at half-integers.
            vec3 voxCoord = fro / size + 0.5;
            voxCoord = mod(voxCoord, 2.0) - 1.0; //Mod by 2, and shift by -1, if its on the border value should be 0.5, in the axis now
            voxCoord += vec3(mask) * sign(rayDir) * 0.5; //Add 0.5 in the direction of the ray, so if its on the exiting border, it will be 0
            float distanceBorder = dot(vec3(mask), voxCoord); //Only check whether the direction we just traversed in is on a border.

            exitoct = abs(distanceBorder) < 0.1; //Error margin
        } else {
            if (currentNode.index != 0u && currentNode.childMask == 0u) {
                if (collisions == 0) {
                    float red = ((currentNode.color >> 16) & 0xFFu) / float(0xFF);
                    float green = ((currentNode.color >> 8) & 0xFFu) / float(0xFF);
                    float blue = (currentNode.color & 0xFFu) / float(0xFF);
                    color = vec3(red, green, blue);

                    //                float intensity = dot(vec3(mask), vec3(0.5, 1.0, 0.75));
                    //                color *= intensity;
                    collisions += 1;
                    rayPos = lro + vec3(fro) + vec3(gridCoord * ubo.width);
                    rayDir = normalize(ubo.lightPosition - rayPos);
                    rdsign = sign(rayDir);
                    irdsign = ivec3(rdsign);
                    ird = 1.0/max(abs(rayDir), 0.001);
                } else {
                    color *= 0.2f;
                    break;
                }


            }

            //If current node is not empty
            if (currentNode.index != 0u && size != 1.0) {
                stack[level] = currentNode;
                level++;
                size *= 0.5;

                vec3 mask2 = step(vec3(size), lro);
                ivec3 imask2 = ivec3(mask2);
                int childIndex = imask2.z * 4 + imask2.y * 2 + imask2.x;
                if (childIndex >= 8) {
                    color = vec3(1.0);
                    break;
                }
                int childOffset = bitCount(currentNode.childMask >> (8 - childIndex));
                uint parentIndex = currentNode.index + childOffset;
                currentNode = (currentNode.childMask >> (7 - childIndex) & 1u) == 1u ? getNode(parentIndex) : empty;

                fro += imask2 * int(size);
                lro -= mask2 * size;
            } else {
                if (level == 0) {
                    //moving while in the highest level, meaning we are out of the voxelSSBOs[0s.vo
                    break;
                }
//                color = level * vec3(0.0, 0.2, 0.0);
                //Move forward to next child
                vec3 hit = voxel(lro, rayDir, ird, size);

                mask = lessThan(hit, min(hit.yzx, hit.zxy));
                float len = dot(hit, vec3(mask));

                dist += len;
                fdist += len;
                //Update lro by updating positions for the axis' we did not traverse too
                //and reset the axis we traversed in to 0
                lro += rayDir * len - (vec3(mask) * rdsign * size);
                ivec3 newfro = fro + ivec3(mask) * irdsign * int(size);

                //Get child coord for parent
                ivec3 childCoord = (newfro / int(size)) % 2;
                int childIndex = childCoord.z * 4 + childCoord.y * 2 + childCoord.x;
                int childOffset = bitCount(stack[level - 1].childMask >> (8 - childIndex));
                uint parentIndex = stack[level - 1].index + childOffset;
                currentNode = (stack[level - 1].childMask >> (7 - childIndex) & 1u) == 1u ? getNode(parentIndex) : empty;


                exitoct = (floor(newfro / size * 0.5 + 0.25)!=floor(fro / size * 0.5 + 0.25));

                fro = newfro;
            }

        }

    }




    imageStore(outputImage, ivec2(pixelCoord), vec4(color, 1.0));
}