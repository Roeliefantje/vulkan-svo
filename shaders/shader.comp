#version 450

struct Particle {
    vec2 position;
    vec2 velocity;
    vec4 color;
};

layout (binding = 0) uniform ParameterUBO {
    int width;
    int height;
    int depth;
} ubo;

layout (binding = 3) uniform CameraUBO {
    vec3 position;
    vec3 direction;
    vec3 up;
    vec2 resolution;
    float fov;
} camera;

//Std430 = tightly packed, std140 is not, no clue how exactly it works...
layout(std430, binding = 1) buffer ParticleSSBOIn {
    uint svo[ ];
};

layout(binding = 2, rgba8) uniform writeonly image2D outputImage;



int MAX_RAY_STEPS = 5000;
#define MAX_DEPTH 16


struct Node {
    uint childMask;
    uint index;
};

struct StackInfo {
    Node node;
    vec3 sideDist;
    ivec3 childCoord;
};


Node convertNode(uint value){
    Node node;
    node.childMask = (value >> 24) & 0xFFu;
    node.index = value & 0x00FFFFFFu;

    return node;
}



bool intersectGrid(vec3 rayDir, vec3 rayPos, out vec3 collision) {
    vec3 invDir = 1.0 / rayDir;

    vec3 t1 = (vec3(0) - rayPos) * invDir;
    vec3 t2 = (vec3(ubo.width, ubo.depth, ubo.height) - rayPos) * invDir;

    vec3 tmin = min(t1, t2);
    vec3 tmax = max(t1, t2);

    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit  = min(min(tmax.x, tmax.y), tmax.z);

    if (tExit >= max(tEnter, 0.0)) {
        collision = rayPos + rayDir * max(tEnter, 0.0);
        return true;
    }

    return false;
}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    uvec2 pixelCoord = gl_GlobalInvocationID.xy;
    vec2 normalized_coord = (vec2(pixelCoord) + 0.5) / camera.resolution * 2.0 - 1.0;

    vec3 forward = camera.direction;
    vec3 right = normalize(cross(forward, camera.up));
    vec3 up = normalize(cross(right, forward));

    // Perspective correction using vertical FOV
    float aspect = camera.resolution.x / camera.resolution.y;
    float fovScale = tan(camera.fov * 0.5);

    vec3 rayDir = normalize(
        forward +
        normalized_coord.x * aspect * fovScale * right +
        normalized_coord.y * fovScale * up
    );

    vec3 rayPos = camera.position;
    //  Distance per axis to travel to the next tile,
    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);
    ivec3 rayStep = ivec3(sign(rayDir));

    int level = 0;
    Node stack[MAX_DEPTH];
    Node currentNode = convertNode(svo[0]);

    vec3 color = vec3(0.1);
    bvec3 mask = bvec3(false, false, true);
    //at level 0, this will be 512, etc.
    int nodeSize = max(1, ubo.width >> level);
    vec3 localPos = fract(rayPos / float(nodeSize)) * 2.0;
    ivec3 childCoords = ivec3(localPos);
    vec3 sideDist = (sign(rayDir) * (vec3(childCoords) - localPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;

    if (any(greaterThan(rayPos / float(nodeSize), vec3(1.0))) || any(greaterThan(vec3(0.0), rayPos / float(nodeSize)))) {
        vec3 collision;
        if (intersectGrid(rayDir, rayPos, collision)){
            rayPos = collision + rayDir * 0.0001f;
        } else {
            imageStore(outputImage, ivec2(pixelCoord), vec4(0.01));
            return;
        }
    }


    for (int i = 0; i < MAX_RAY_STEPS; i++){
        if (currentNode.childMask == 0u || level == MAX_DEPTH) {
            //Ray collided with voxel
            color = vec3(dot(vec3(mask), vec3(0.5, 1.0, 0.75)));
            break;
        }

        int childIndex = childCoords.z * 4 + childCoords.y * 2 + childCoords.x;
        if (((currentNode.childMask >> (7 - childIndex)) & 1u) == 1u) {
            //Descend
            stack[level] = currentNode;
            level += 1;
            int childOffset = bitCount(currentNode.childMask >> (8 - childIndex));
            currentNode = convertNode(svo[currentNode.index + childOffset]);

            nodeSize = max(1, ubo.width >> level);
            localPos = fract(rayPos / float(nodeSize)) * 2.0;
            childCoords = ivec3(localPos);
            sideDist = (sign(rayDir) * (vec3(childCoords) - localPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
        } else {
            //DDA to next child
            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
            childCoords += ivec3(vec3(mask)) * rayStep;

            if (any(lessThan(childCoords, ivec3(0))) || any(greaterThan(childCoords, ivec3(1)))) {
                //Ascend
                rayPos += dot(vec3(mask), sideDist) * rayDir * (nodeSize / 2.0);
                level -= 1;
                if (level < 0) {
                    break;
                }

                currentNode = stack[level];

                nodeSize = max(1, ubo.width >> level);
                localPos = fract(rayPos / float(nodeSize)) * 2.0;
                childCoords = ivec3(localPos);
                sideDist = (sign(rayDir) * (vec3(childCoords) - localPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
                break;
            }

            sideDist += vec3(mask) * deltaDist;
        }


    }
    imageStore(outputImage, ivec2(pixelCoord), vec4(color, 1.0));
}