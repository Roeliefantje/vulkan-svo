#version 450

struct Particle {
    vec2 position;
    vec2 velocity;
    vec4 color;
};

layout (binding = 0) uniform ParameterUBO {
    int width;
    int height;
    int depth;
} ubo;

layout (binding = 3) uniform CameraUBO {
    vec3 position;
    vec3 direction;
    vec3 up;
    vec2 resolution;
    float fov;
} camera;

//Std430 = tightly packed, std140 is not, no clue how exactly it works...
layout(std430, binding = 1) buffer ParticleSSBOIn {
    uint svo[ ];
};

layout(binding = 2, rgba8) uniform writeonly image2D outputImage;



int MAX_RAY_STEPS = 5000;
#define MAX_DEPTH 16


struct Node {
    uint childMask;
    uint index;
};

struct StackInfo {
    Node node;
    vec3 sideDist;
    ivec3 childCoord;
};


Node convertNode(uint value){
    Node node;
    node.childMask = (value >> 24) & 0xFFu;
    node.index = value & 0x00FFFFFFu;

    return node;
}



bool intersectGrid(vec3 rayDir, vec3 rayPos, out vec3 collision) {
    vec3 invDir = 1.0 / rayDir;

    vec3 t1 = (vec3(0) - rayPos) * invDir;
    vec3 t2 = (vec3(ubo.width, ubo.depth, ubo.height) - rayPos) * invDir;

    vec3 tmin = min(t1, t2);
    vec3 tmax = max(t1, t2);

    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit  = min(min(tmax.x, tmax.y), tmax.z);

    if (tExit >= max(tEnter, 0.0)) {
        collision = rayPos + rayDir * max(tEnter, 0.0);
        return true;
    }

    return false;
}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    uvec2 pixelCoord = gl_GlobalInvocationID.xy;
    vec2 normalized_coord = (vec2(pixelCoord) + 0.5) / camera.resolution * 2.0 - 1.0;

    vec3 forward = camera.direction;
    vec3 right = normalize(cross(forward, camera.up));
    vec3 up = normalize(cross(right, forward));

    // Perspective correction using vertical FOV
    float aspect = camera.resolution.x / camera.resolution.y;
    float fovScale = tan(camera.fov * 0.5);

    vec3 rayDir = normalize(
        forward +
        normalized_coord.x * aspect * fovScale * right +
        normalized_coord.y * fovScale * up
    );

    vec3 rayPos = camera.position;

    //Collision check
    if (any(greaterThan(rayPos / float(ubo.width), vec3(1.0))) || any(greaterThan(vec3(0.0), rayPos / float(ubo.width)))) {
        vec3 collision;
        if (intersectGrid(rayDir, rayPos, collision)){
            rayPos = collision + rayDir * 0.0001f;
        } else {
            imageStore(outputImage, ivec2(pixelCoord), vec4(0.01));
            return;
        }
    }

    //  Distance per axis to travel to the next tile,
    vec3 invRayDir = 1.0 / rayDir;
    ivec3 rayStep = ivec3(sign(rayDir));

    int level = 0;
    StackInfo stack[MAX_DEPTH];
    Node currentNode = convertNode(svo[0]);
    vec3 color = vec3(0.1);

    //Initial DDA setup
    float nodeSize = max(1, ubo.width >> level);
    vec3 deltaDist = abs(vec3(float(nodeSize) * 0.5) * invRayDir);

    //Position within the root Node [0, 1]
    vec3 localPos = fract(rayPos / float(nodeSize)) * 2.0;
    ivec3 childCoords = ivec3(localPos);

    vec3 sideDist = (sign(rayDir) * (vec3(childCoords) - localPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
//    vec3 sideDist = (sign(rayDir) * (vec3(childCoords) * 0.5 + 0.5 - localPos) + 0.5) * deltaDist;

    //at level 0, this will be 512, etc.



    for (int i = 0; i < MAX_RAY_STEPS; i++) {
        //Check if current Node is leaf or max depth
        if (currentNode.childMask == 0u || level == MAX_DEPTH) {
            vec3 hitNormal = -sign(rayDir) * vec3(lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy)));
            color = vec3(0.5) + hitNormal * 0.5; // Color based on normal
            break;
        }

        // --- DDA Step ---
        // Find which axis to step along
        bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
        float t_step = dot(vec3(mask), sideDist); // Min distance to next boundary

        int childIndex = childCoords.z * 4 + childCoords.y * 2 + childCoords.x;
        //Child exists
        if (((currentNode.childMask >> (7 - childIndex)) & 1u) == 1u) {
            //Save current state before descending but advance sideStep and childCoord so we do not check the same node twice
            stack[level].node = currentNode;
            stack[level].sideDist = sideDist + (vec3(mask) * deltaDist);
            stack[level].childCoord = childCoords + (ivec3(mask) * rayStep);

            int childOffset = bitCount(currentNode.childMask >> (8 - childIndex));
            currentNode = convertNode(svo[currentNode.index + childOffset]);
            level++;
            localPos = fract(rayPos / float(nodeSize)) * 2.0;
            childCoords = ivec3(localPos);
            deltaDist *= 0.5;
            sideDist = (sign(rayDir) * (vec3(childCoords) - localPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
            continue;
        }

        //DDA as normal
        sideDist += vec3(mask) * deltaDist;
        childCoords += ivec3(mask) * rayStep;

        if (any(lessThan(childCoords, ivec3(0))) || any(greaterThan(childCoords, ivec3(1)))) {
            //Ascend
            level--;
            if (level < 0) {
                color = vec3(0.01);
                break;
            }

            currentNode = stack[level].node;
            sideDist = stack[level].sideDist;
            childCoords = stack[level].childCoord;

            nodeSize = max(1, ubo.width >> level);
            deltaDist = abs(vec3(float(nodeSize) * 0.5) / rayDir);
            continue;
        }
    }


    imageStore(outputImage, ivec2(pixelCoord), vec4(color, 1.0));
}