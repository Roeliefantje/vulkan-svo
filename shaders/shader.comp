#version 450
#extension GL_EXT_nonuniform_qualifier : require
//Look at: https://www.shadertoy.com/view/4sVfWw

struct Particle {
    vec2 position;
    vec2 velocity;
    vec4 color;
};

layout (binding = 0) uniform ParameterUBO {
    uint width;
    uint height;
    uint depth;
    uint bufferSize;
} ubo;

layout (binding = 3) uniform CameraUBO {
    vec3 position;
    vec3 direction;
    vec3 up;
    vec2 resolution;
    float fov;
} camera;

//Std430 = tightly packed, std140 is not, no clue how exactly it works...
layout(std430, binding = 4) buffer VoxelSSBO{
    uint svo[ ];
} voxelSSBOs[];

layout(std430, binding = 1) buffer FarValuesSSBO {
    uint farValues[ ];
};

layout(binding = 2, rgba8) uniform writeonly image2D outputImage;




int MAX_RAY_STEPS = 5000;
#define MAX_DEPTH 16
#define MAX_DISTANCE 30000.0


struct Node {
    uint childMask;
    uint index;
};

struct StackInfo {
    Node node;
    vec3 sideDist;
    ivec3 childCoord;
};


//CHILD OFFSET IS MESSING WITH FAR VALUES, SHOULD DO IT DIFFERENTLY I SUPPOSE
//Shouldnt be true ^^, I dont know anymore...
Node convertNode(uint value, uint parentIndex){
    Node node;
    node.childMask = (value >> 24) & 0xFFu;
    bool isFar = (value & (1u << 23)) != 0u;
    uint childIndex = value & 0x007FFFFFu;
    node.index = (isFar ? farValues[childIndex] : childIndex) + parentIndex;

    return node;
}

Node getNode(uint index) {
    uint chunkIndex = index / ubo.bufferSize;
    uint svoIndex = index % ubo.bufferSize;
    uint value = voxelSSBOs[chunkIndex].svo[svoIndex];

    return convertNode(value, index);
}



bool intersectGrid(vec3 rayDir, vec3 rayPos, out vec3 collision) {
    vec3 invDir = 1.0 / rayDir;

    vec3 t1 = (vec3(0.0) - rayPos) * invDir;
    vec3 t2 = (vec3(ubo.width) - rayPos) * invDir;

    vec3 tmin = min(t1, t2);
    vec3 tmax = max(t1, t2);

    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit  = min(min(tmax.x, tmax.y), tmax.z);

    if (tExit >= max(tEnter, 0.0)) {
        collision = rayPos + rayDir * max(tEnter, 0.0);
        return true;
    }

    return false;
}

vec3 voxel(vec3 ro, vec3 rd, vec3 ird, float size)
{
    size *= 0.5;

    vec3 hit = -(sign(rd)*(ro-size)-size)*ird;

    return hit;
}


layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    uvec2 pixelCoord = gl_GlobalInvocationID.xy;
    vec2 normalized_coord = (vec2(pixelCoord) + 0.5) / camera.resolution * 2.0 - 1.0;

    vec3 forward = camera.direction;
    vec3 right = normalize(cross(forward, camera.up));
    vec3 up = normalize(cross(right, forward));

    // Perspective correction using vertical FOV
    float aspect = camera.resolution.x / camera.resolution.y;
    float fovScale = tan(camera.fov * 0.5);

    vec3 rayDir = normalize(
        forward +
        normalized_coord.x * aspect * fovScale * right +
        normalized_coord.y * fovScale * up
    );

    vec3 rayPos = camera.position;
    ivec3 rayStep = ivec3(sign(rayDir)); //The directino of the ray

    //Initialize stuffs
    float size = ubo.width;
    int level = 0;
    Node stack[MAX_DEPTH];
    Node currentNode = getNode(0);
    Node empty;
    empty.index = 0;

    //Check if the ray collides with the Ray at all, move it into the SVO if it is the case and return if not.
    if (any(greaterThan(rayPos / size, vec3(1.0))) || any(greaterThan(vec3(0.0), rayPos / size))) {
        vec3 collision;
        if (intersectGrid(rayDir, rayPos, collision)){
            rayPos = collision;
        } else {
            imageStore(outputImage, ivec2(pixelCoord), vec4(0.01));
            return;
        }
    }

    vec3 color = vec3(0.1);
    bvec3 mask = bvec3(false, false, false);

    vec3 lro = mod(rayPos, size); // Local ray origin (Should always already be inside 1.0, but for sanity)
    ivec3 fro = ivec3(rayPos - lro); //The global voxel position we are currently in (should always start as 0,0,0)
    vec3 rdsign = sign(rayDir);
    ivec3 irdsign = ivec3(rdsign);
    vec3 ird = 1.0/max(abs(rayDir), 0.001); //inv ray dir to calculate the distance to voxel boundaries and stuff
    bool exitoct = false;
    float dist = 0.0; //Total distance the ray traversed
    float fdist = 0.0;

    for(int i = 0; i < MAX_RAY_STEPS; i++) {
        if(dist > MAX_DISTANCE) break;

        if (exitoct) {
            //Todo!: Improve this to do it in one go
            //Snap newfro to multiple of new size to get the global voxel position again
            ivec3 newfro = ivec3(floor( vec3(fro) / (size * 2.0))) * (int(size) * 2);


            lro += fro - newfro;
            fro = newfro;
            size *= 2.0;

            level--;
            if (level <= 0) {
                break;
            }
//            color += vec3(0.0, 0.0, 0.1);

            ivec3 childCoord = (newfro / int(size)) % 2;
            int childIndex = childCoord.z * 4 + childCoord.y * 2 + childCoord.x;
            if (childIndex >= 8) {
                color = vec3(1.0);
                break;
            }
            int childOffset = bitCount(stack[level - 1].childMask >> (8 - childIndex));
            uint parentIndex = stack[level - 1].index + childOffset;
            currentNode = (stack[level - 1].childMask >> (7 - childIndex) & 1u) == 1u ? getNode(parentIndex) : empty;
//            currentNode = (stack[level - 1].childMask >> (7 - childIndex) & 1u) == 1u ? convertNode(voxelSSBOs[0].svo[stack[level - 1].index + childOffset], parentIndex) : empty;

            //Fetch the new voxCoord and see if it is still on a border
            // +0.5 centers the voxel range so borders lie at half-integers.
            vec3 voxCoord = fro / size + 0.5;
            voxCoord = mod(voxCoord, 2.0) - 1.0; //Mod by 2, and shift by -1, if its on the border value should be 0.5, in the axis now
            voxCoord += vec3(mask) * sign(rayDir) * 0.5; //Add 0.5 in the direction of the ray, so if its on the exiting border, it will be 0
            float distanceBorder = dot(vec3(mask), voxCoord); //Only check whether the direction we just traversed in is on a border.

            exitoct = abs(distanceBorder) < 0.1; //Error margin
        } else {
            if (currentNode.index != 0u && currentNode.childMask == 0u) {
                float red = dot(vec3(mask), vec3(0.5, 1.0, 0.75));
                color += vec3(red, 0.0, 0.0);
                break;
            }

            //If current node is not empty
            if (currentNode.index != 0u && size != 1.0) {
                stack[level] = currentNode;
                level++;
                size *= 0.5;

                vec3 mask2 = step(vec3(size), lro);
                ivec3 imask2 = ivec3(mask2);
                int childIndex = imask2.z * 4 + imask2.y * 2 + imask2.x;
                if (childIndex >= 8) {
                    color = vec3(1.0);
                    break;
                }
                int childOffset = bitCount(currentNode.childMask >> (8 - childIndex));
                uint parentIndex = currentNode.index + childOffset;
                currentNode = (currentNode.childMask >> (7 - childIndex) & 1u) == 1u ? getNode(parentIndex) : empty;

                fro += imask2 * int(size);
                lro -= mask2 * size;
            } else {
                if (level == 0) {
                    //moving while in the highest level, meaning we are out of the voxelSSBOs[0s.vo
                    break;
                }
//                color = level * vec3(0.0, 0.2, 0.0);
                //Move forward to next child
                vec3 hit = voxel(lro, rayDir, ird, size);

                mask = lessThan(hit, min(hit.yzx, hit.zxy));
                float len = dot(hit, vec3(mask));

                dist += len;
                fdist += len;
                //Update lro by updating positions for the axis' we did not traverse too
                //and reset the axis we traversed in to 0
                lro += rayDir * len - (vec3(mask) * rdsign * size);
                ivec3 newfro = fro + ivec3(mask) * irdsign * int(size);

                //Get child coord for parent
                ivec3 childCoord = (newfro / int(size)) % 2;
                int childIndex = childCoord.z * 4 + childCoord.y * 2 + childCoord.x;

                if (childIndex >= 8) {
                    color = vec3(1.0);
                    break;
                }

                int childOffset = bitCount(stack[level - 1].childMask >> (8 - childIndex));
                uint parentIndex = stack[level - 1].index + childOffset;
                currentNode = (stack[level - 1].childMask >> (7 - childIndex) & 1u) == 1u ? getNode(parentIndex) : empty;


                exitoct = (floor(newfro / size * 0.5 + 0.25)!=floor(fro / size * 0.5 + 0.25));

                fro = newfro;
            }

        }

    }




    imageStore(outputImage, ivec2(pixelCoord), vec4(color, 1.0));
}