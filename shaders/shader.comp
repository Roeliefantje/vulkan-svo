#version 450

struct Particle {
    vec2 position;
    vec2 velocity;
    vec4 color;
};

layout (binding = 0) uniform ParameterUBO {
    int width;
    int height;
    int depth;
} ubo;

layout (binding = 3) uniform CameraUBO {
    vec3 position;
    vec3 lookAt;
    vec3 up;
    vec2 resolution;
    float fov;
} camera;

layout(std140, binding = 1) buffer ParticleSSBOIn {
    int gridValues[ ];
};

layout(binding = 2, rgba8) uniform writeonly image2D outputImage;



int MAX_RAY_STEPS = 1000;



int getIndex(ivec3 mapPos) {
//    gl_GlobalInvocationID.x + ubo.depth * gl_GlobalInvocationID.y + ubo.height * ubo.depth * gl_GlobalInvocationID.z;
    return int(dot(mapPos, ivec3(1, ubo.depth, ubo.depth * ubo.height)));
}

int getValue(ivec3 mapPos) {
    if (any(greaterThanEqual(mapPos, ivec3(ubo.width, ubo.depth, ubo.height))) || any(greaterThan(ivec3(0), mapPos))) {
        return 0;
    }
    int index = getIndex(mapPos);
    if (index >= ubo.width * ubo.height * ubo.depth || index < 0) {
        return 0;
    }

    return gridValues[index];
}

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uvec2 pixelCoord = gl_GlobalInvocationID.xy;
    vec2 normalized_coord = (vec2(pixelCoord) + 0.5) / camera.resolution * 2.0 - 1.0;

    vec3 forward = normalize(camera.lookAt - camera.position);
    vec3 right = normalize(cross(forward, camera.up));
    vec3 up = normalize(cross(right, forward));

    // Perspective correction using vertical FOV
    float aspect = camera.resolution.x / camera.resolution.y;
    float fovScale = tan(camera.fov * 0.5);

    vec3 rayDir = normalize(
        forward +
        normalized_coord.x * aspect * fovScale * right +
        normalized_coord.y * fovScale * up
    );

//    imageStore(outputImage, ivec2(pixelCoord), vec4( camera.position / 1000.0, 1.0));
    imageStore(outputImage, ivec2(pixelCoord), vec4( abs(rayDir), 1.0));
////    imageStore(outputImage, ivec2(pixelCoord), vec4(1.0, 1.0, 1.0, 1.0));
//    return;

//    rayDir += vec3(1e-24, 1e-24, 1e-24);

    vec3 rayPos = camera.position;

    ivec3 mapPos = ivec3(floor(rayPos));
//  Distance per axis to travel to the next floor
    vec3 deltaDist = abs(1.0 / rayDir);

//    vec3 deltaDist;
//    // Use `abs(rayDir)` for the conditional check and division
//    vec3 absRayDir = abs(rayDir);
//
//    deltaDist.x = (absRayDir.x == 0.0) ? 1e38 : 1.0 / absRayDir.x;
//    deltaDist.y = (absRayDir.y == 0.0) ? 1e38 : 1.0 / absRayDir.y;
//    deltaDist.z = (absRayDir.z == 0.0) ? 1e38 : 1.0 / absRayDir.z;

    ivec3 rayStep = ivec3(sign(rayDir));
    vec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
    bvec3 mask = bvec3(false, false, true);

    for (int i = 0; i < MAX_RAY_STEPS; i++) {
//        if (any(greaterThan(mapPos, ivec3(ubo.width, ubo.depth, ubo.height))));
        if (getValue(mapPos) == 1) break;
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

        sideDist += vec3(mask) * deltaDist;
        mapPos += ivec3(vec3(mask)) * rayStep;

    }

    vec3 color = vec3(dot(vec3(mask), vec3(0.5, 1.0, 0.75)));
    if (getValue(mapPos) == 0) {
        color = vec3(0.1, 0.1, 0.1);
    }
//
//    if (getValue(mapPos) == 1) {
//        color = vec3(1.0, 1.0, 1.0);
//    }


    imageStore(outputImage, ivec2(pixelCoord), vec4(color, 1.0));

}