#version 450
#extension GL_EXT_nonuniform_qualifier : require
//Look at: https://www.shadertoy.com/view/4sVfWw
#define DEBUG_VALUES 1
#define SHOWSTEPS

struct Particle {
    vec2 position;
    vec2 velocity;
    vec4 color;
};

struct Chunk {
    uint farValuesOffset;
    uint rootNodeIndex;
};

layout (binding = 0) uniform ParameterUBO {
    vec3 lightPosition;
    uint width;
    uint bufferSize;
    uint gridSize;
    uint gridHeight;
} ubo;

layout (binding = 3) uniform CameraUBO {
    vec3 position;
    vec3 direction;
    vec3 up;
    ivec3 camera_grid_pos;
    vec2 resolution;
    float fov;
} camera;

layout(std430, binding = 5) buffer DebugSSBO{
    uint totalSteps;
    uint maxSteps;
} debugValues;

//Std430 = tightly packed, std140 is not, no clue how exactly it works...
layout(std430, binding = 6) buffer VoxelSSBO{
    uint svo[ ];
} voxelSSBOs[];

layout(std430, binding = 4) buffer gridSSBO {
    Chunk grid[ ];
};

layout(std430, binding = 1) buffer FarValuesSSBO {
    uint farValues[ ];
};

layout(binding = 2, rgba8) uniform writeonly image2D outputImage;




int MAX_RAY_STEPS = 500;
#define MAX_DEPTH 16
#define MAX_DISTANCE 300000.0


struct Node {
    uint childMask;
    uint index;
    uint color;
};

struct StackInfo {
    Node node;
    vec3 sideDist;
    ivec3 childCoord;
};

vec3 heatmap(float t) {
    // smooth interpolation between colors
    vec3 green = vec3(0.0, 1.0, 0.0);
    vec3 yellow = vec3(1.0, 1.0, 0.0);
    vec3 red = vec3(1.0, 0.0, 0.0);

    // You can use smoothstep to get a smoother gradient
    if (t < 0.5) {
        return mix(green, yellow, smoothstep(0.0, 0.5, t));
    } else {
        return mix(yellow, red, smoothstep(0.5, 1.0, t));
    }
}

Node convertNode(uint value, uint parentIndex, uint farValuesOffset){
    Node node;
    node.childMask = (value >> 24) & 0xFFu;
    bool isFar = (value & (1u << 23)) != 0u;
    uint childIndex = value & 0x007FFFFFu;
    node.index = (isFar ? farValues[farValuesOffset + childIndex] : childIndex) + parentIndex;
    node.color = value & 0x00FFFFFFu;;

    return node;
}

Node getNode(uint index, uint farValuesOffset) {
    uint chunkIndex = index / ubo.bufferSize;
    uint svoIndex = index % ubo.bufferSize;
    uint value = voxelSSBOs[chunkIndex].svo[svoIndex];

    return convertNode(value, index, farValuesOffset);
}

vec3 voxel(vec3 ro, vec3 rd, vec3 ird, float size)
{
    size *= 0.5;

    vec3 hit = -(sign(rd)*(ro-size)-size)*ird;

    return hit;
}

//vec3 positive_mod(vec3 x, vec3 y) {
//    return mod(mod(x, y) + y, y);
//}

ivec2 positive_mod(ivec2 a, float b) {
    int x_val = int(a.x - b * floor(a.x / b));
    int y_val = int(a.y - b * floor(a.y / b));

    return ivec2(
        x_val < 0 ? x_val + b : x_val,
        y_val < 0 ? y_val + b : y_val
    );
}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    uvec2 pixelCoord = gl_GlobalInvocationID.xy;
    vec2 normalized_coord = (vec2(pixelCoord) + 0.5) / camera.resolution * 2.0 - 1.0;
    normalized_coord.y = -normalized_coord.y;

    vec3 forward = camera.direction;
    vec3 right = normalize(cross(forward, camera.up));
    vec3 up = normalize(cross(right, forward));

    // Perspective correction using vertical FOV
    float aspect = camera.resolution.x / camera.resolution.y;
    float fovScale = tan(camera.fov * 0.5);

    vec3 rayDir = normalize(
        forward +
        normalized_coord.x * aspect * fovScale * right +
        normalized_coord.y * fovScale * up
    );

    vec3 rayPos = camera.position;
    ivec3 rayStep = ivec3(sign(rayDir)); //The direction of the ray

    //Initialize stuffs

    float size = ubo.width;
    ivec3 gridCoord = camera.camera_grid_pos;

//    ivec3 gridCoord = ivec3(rayPos / size);

    int level = 0;
    Chunk currentChunk = grid[(gridCoord.z * ubo.gridSize * ubo.gridSize) + (gridCoord.y * ubo.gridSize) + gridCoord.x];
    Node stack[MAX_DEPTH];
    Node currentNode = getNode(currentChunk.rootNodeIndex, currentChunk.farValuesOffset);
    uint farValueOffset = currentChunk.farValuesOffset;
    Node empty;
    empty.index = 0;

    if (any(greaterThanEqual(gridCoord, ivec3(ubo.gridSize, ubo.gridSize, ubo.gridHeight))) || any(lessThan(gridCoord, ivec3(0)))) {
        currentNode = empty;
    }

    //Skyblue color
    vec3 color = vec3(0.51, 0.784, 0.898);


    bvec3 mask = bvec3(false, false, false);

    vec3 lro = rayPos;
//    vec3 lro = rayPos - vec3(gridCoord) * size;
    ivec3 fro = ivec3(0); //The global voxel position we are currently in (should always start as 0,0,0)
    vec3 rdsign = sign(rayDir);
    ivec3 irdsign = ivec3(rdsign);
    vec3 ird = 1.0/max(abs(rayDir), 0.001); //inv ray dir to calculate the distance to voxel boundaries and stuff
    bool exitoct = false;
    bool movegrid = false;
    float dist = 0.0; //Total distance the ray traversed
    float fdist = 0.0;
    int collisions = 0;
    float intensity = 1.0;
    uint steps = 0;
    ivec3 gridsMoved = ivec3(0);
    ivec2 gridRD = ivec2((ubo.gridSize - 1) / 2, (ubo.gridSize - 1) / 2);

    for(int i = 0; i < MAX_RAY_STEPS; i++) {
        steps += 1;
        if(dist > MAX_DISTANCE) break;

        if (movegrid) {
            //Outside of current Octree, move grid coords and go from there
            size = ubo.width;
            level = 0;
            rayPos = lro + vec3(fro) + vec3(gridCoord * ubo.width);
            gridCoord += ivec3(mask) * irdsign;
            lro = rayPos - vec3(gridCoord) * ubo.width;
            fro = ivec3(0);

            int gridSize = int(ubo.gridSize);

            gridCoord = ivec3(positive_mod(gridCoord.xy, gridSize), gridCoord.z);
            gridsMoved +=  ivec3(mask) * irdsign;; //Keep track of how many grids we have passed


            currentChunk = grid[(gridCoord.z * ubo.gridSize * ubo.gridSize) + (gridCoord.y * ubo.gridSize) + gridCoord.x];
//            currentChunk = grid[(positive_mod(gridCoord.y, gridSize) * gridSize) + positive_mod(gridCoord.x, gridSize)];
            currentNode = getNode(currentChunk.rootNodeIndex, currentChunk.farValuesOffset);
            if (gridCoord.z >= int(ubo.gridHeight)) {
                currentNode = empty;
            }
            farValueOffset = currentChunk.farValuesOffset;

            if (any(greaterThan(abs(gridsMoved.xy), gridRD))) {
//                color = vec3(1.0, 0.0, 0.0);
                break;
            }
            if ((gridCoord.z >= ubo.gridHeight && rdsign.z > 0) ||
                (gridCoord.z < 0 && rdsign.z < 0)
            ) {
                break;
            }
//
//            if (any(greaterThanEqual(gridCoord, ivec3(ubo.gridSize, ubo.gridSize, 1))) || any(lessThan(gridCoord, ivec3(0)))) {
//                break;
//            }

            movegrid = false;
            exitoct = false;
        }

        if (exitoct) {
            //Todo!: Improve this to do it in one go
            //Use the
            //Snap newfro to multiple of new size to get the global voxel position again
            ivec3 newfro = ivec3(floor( vec3(fro) / (size * 2.0))) * (int(size) * 2);


            lro += fro - newfro;
            fro = newfro;
            size *= 2.0;

            level--;
            if (level <= 0) {
                movegrid = true;
                continue;
            }

            ivec3 childCoord = (newfro / int(size)) % 2;
            int childIndex = childCoord.z * 4 + childCoord.y * 2 + childCoord.x;
            int childOffset = bitCount(stack[level - 1].childMask >> (8 - childIndex));
            uint parentIndex = stack[level - 1].index + childOffset;
            currentNode = (stack[level - 1].childMask >> (7 - childIndex) & 1u) == 1u ? getNode(parentIndex, farValueOffset) : empty;

            //Fetch the new voxCoord and see if it is still on a border
            // +0.5 centers the voxel range so borders lie at half-integers.
            vec3 voxCoord = fro / size + 0.5;
            voxCoord = mod(voxCoord, 2.0) - 1.0; //Mod by 2, and shift by -1, if its on the border value should be 0.5, in the axis now
            voxCoord += vec3(mask) * sign(rayDir) * 0.5; //Add 0.5 in the direction of the ray, so if its on the exiting border, it will be 0
            float distanceBorder = dot(vec3(mask), voxCoord); //Only check whether the direction we just traversed in is on a border.

            exitoct = abs(distanceBorder) < 0.1; //Error margin
        } else {
            //Hit voxel
            if (currentNode.index != 0u && currentNode.childMask == 0u) {
                if (collisions == 0) {
                    float red = ((currentNode.color >> 16) & 0xFFu) / float(0xFF);
                    float green = ((currentNode.color >> 8) & 0xFFu) / float(0xFF);
                    float blue = (currentNode.color & 0xFFu) / float(0xFF);
                    color = vec3(red, green, blue);
                    vec3 normal = -1 * rdsign * vec3(mask);

                    collisions += 1;
                    rayDir = normalize(vec3(0.5, 3, 2));
                    intensity = clamp(dot(normal, rayDir) + 0.2f, 0.0f, 1.0f);

                    if (intensity <= 0.2f) {
                        break;
                    }
                    //Update values we use for the traversal
                    rdsign = sign(rayDir);
                    irdsign = ivec3(rdsign);
                    ird = 1.0/max(abs(rayDir), 0.001);
//                    break;
                } else {
                    intensity = 0.2f;
                    break;
                }


            }

            //If current node is not empty
            if (currentNode.index != 0u && currentNode.childMask != 0u && size != 1.0) {
                stack[level] = currentNode;
                level++;
                size *= 0.5;

                vec3 mask2 = step(vec3(size), lro);
                ivec3 imask2 = ivec3(mask2);
                int childIndex = imask2.z * 4 + imask2.y * 2 + imask2.x;
                int childOffset = bitCount(currentNode.childMask >> (8 - childIndex));
                uint parentIndex = currentNode.index + childOffset;
                currentNode = (currentNode.childMask >> (7 - childIndex) & 1u) == 1u ? getNode(parentIndex, farValueOffset) : empty;

                fro += imask2 * int(size);
                lro -= mask2 * size;
            } else {
                if (level == 0) {
                    //moving while in the highest level, meaning we are out of the voxelSSBOs[0s.vo
                    movegrid = true;
                }
                //Move forward to next child
                vec3 hit = voxel(lro, rayDir, ird, size);

                mask = lessThan(hit, min(hit.yzx, hit.zxy));
                float len = dot(hit, vec3(mask));

                dist += len;
                fdist += len;
                //Update lro by updating positions for the axis' we did not traverse too
                //and reset the axis we traversed in to 0
                lro += rayDir * len - (vec3(mask) * rdsign * size);
                ivec3 newfro = fro + ivec3(mask) * irdsign * int(size);

                //Get child coord for parent
                ivec3 childCoord = (newfro / int(size)) % 2;
                int childIndex = childCoord.z * 4 + childCoord.y * 2 + childCoord.x;
                int childOffset = bitCount(stack[level - 1].childMask >> (8 - childIndex));
                uint parentIndex = stack[level - 1].index + childOffset;
                currentNode = (stack[level - 1].childMask >> (7 - childIndex) & 1u) == 1u ? getNode(parentIndex, farValueOffset) : empty;


                exitoct = (floor(newfro / size * 0.5 + 0.25)!=floor(fro / size * 0.5 + 0.25));

                fro = newfro;
            }

        }

    }

    #ifdef SHOWSTEPS
        float t = clamp(steps / float(MAX_RAY_STEPS), 0.0, 1.0);
        color = heatmap(t);
        intensity = 1.0;
    #endif

    #if DEBUG_VALUES
        atomicAdd(debugValues.totalSteps, steps);
        atomicMax(debugValues.maxSteps, steps);
    #endif

    intensity = clamp(intensity, 0.2f, 1.0f);

    //Display grid coords with colors
//    color *= vec3(gridCoord.x / float(ubo.gridSize), gridCoord.y, 1.0);

    imageStore(outputImage, ivec2(pixelCoord), vec4(color * intensity, 1.0));
}